#### 용어 정리
<span style="color:blue">FEP (Front-End Processor) </span> <br>
        : 입력되는 데이터를 컴퓨터 프로세서가 처리하기 전 미리 처리해 프로세서가 처리하는 시간 줄여주는 프로그램 or 하드웨어

<span style="color:blue">EAI (Enterprise Application Integration) </span> <br>
        : 비즈니스 프로세스 중심으로 어댑터 이용해 기업 내 각종 플랫폼 및 애플리케이션 간 상호 연동 가능하도록 통합하는 솔루션

<span style="color:blue">GPL (General Public License) </span> <br>
        : 자유 소프트웨어 재단에서 만든 오픈 소스 소프트웨어 라이선스
          GPL 파생 저작물 조항에 의한 소스 코드 배포 의무 O

    DuPlexing
        : 단일 매체, 장치, 포트에서 '동시 양방향 통신' 가능하게 하는 전송방식

    위험 모니터링
        : 위험 요소 징후들에 대해 계속적으로 인지하는 것

    SRS (Software REquest Specification)
        : 시스템에서 구현되어야 할 것에 대한 공식적인 문장으로 사용자, 시스템을 명세화한 산출물

    Tailoring
        : 프로젝트 특성과 필요 따라 소프트웨어 개발 프로세스를 적합한 규모로 가공하는 과정 및 방법론
    
    CMMi
        : 기존 CMM 모델 통합하고 ISO15504 준수하는 소프트웨어 개발 능력 / 성숙도 평가 및 프로세스 개선 활동의 지속적인 품질 개선 모델
    
    SPICE
        : 소프트웨어 프로세스 평가하고 개선함으로 품질 및 생산성 높이고자 하는 국제표준 (ISO15504)

    추상화 (Abstraction) 
        : 공통 성질을 추출해 추상 클래스를 설정하는 기법

    캡슐화 (Encapsulation)
        : 서로 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만 밖으로 드러내는 기법

    UML
        : 객체지향 시스템 개발 시 산출물을 명세화, 시각화, 문서화하는 데 사용됨
          개발하는 시스템을 이해하기 쉬운 형태로 표현해 분석가, 의뢰인, 설계자가 효율적인 의사소통 할 수 있게 해줌
          개발 방법론 or 개발 프로세스가 아닌 표준화된 모델링 언어

    목업 (Mockup)
        : 디자인, 사용방법설명, 평가 등 위해 실제 화면과 유사하게 만든 정적 형태 모형
          시각적으로만 구성요소 배치하는 것으로 일반적으로 실제로 구현되지 X

    스토리보드 (Storyboard)
        : 정책, 프로세스, 콘텐츠 구성, 와이어프레임 (UI, UX), 기능 정의, 데이터베이스 연동 등 서비스 구축을 위한 모든 정보 담긴 설계 산출물

    프로토타입 (Prototype)
        : 정적 화면으로 설계된 와이어프레임 or 스토리보드에 동적 효과를 적용함으로써 실제 구현된 것처럼 시뮬레이션할 수 있는 모형

    디자인 패턴
        : 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법 정리한 패턴
          디자인 패턴 참고해 개발 시 개발 효율성, 유지 보수성, 운용성 등 품질 높아지며 프로그램 최적화에 도움됨


    럼바우 (Rumbaugh Method)
        : 객체지향 분석 기법 중 하나
          그래픽 표기법 이용해 소프트웨어 구성요소를 모델링하는 기법
          객체 모형, 동적 모형, 기능 모형의 3개 모형 생성

<span style="color:blue"> 클래스 (Class) </span> <br>
        : 객체 지향 개념 중 하나 이상의 유사한 객체들을 묶어 공통된 특성 표현한 데이터 추상화를 의미하는 것 <br>
          공통의 속성 공유하는 객체들 집합

    메서드 (Method)
        : 클래스로부터 생성된 객체 사용하는 방법

    필드 (Field)
        : 클래스에 포함된 변수 (Variable)

    메시지 (Message)
        : 객체 간 상호작용 하기 위한 수단
          객체에게 어떤 행위 하도록 지시하는 방법

    비기능적 요구사항 
        : 시스템 특성, 품질, 제약사항, 성능, 가용성, 사용 용이성, 유지보수 용이성, 안전성, 보안성 관련 사항
          (ex) 차량 대여 시스템이 제공하는 모든 화면이 3초 내 사용자에게 보여야 한다 -> 성능과 관계된 비기능적 요구사항

    ERD (Entity-Relationship Diagram)
        : 정보공학 방법론에서 데이터베이스 설계 표현으로 사용하는 모델링 언어

    패키지 다이어그램 (Package Diagram)
        : 유스케이스 or 클래스 등 모델 요소들을 그룹화한 패키지들의 관계 표현하는 다이어그램

    상태 전이 다이어그램 (State Transition Diagram)
        : 하나의 객체가 자신이 속한 클래스의 상태 변화 or 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현하는 다이어그램
          모든 가능한 상태와 전이 표현
          진입 조건, 탈출 조건, 상태 전이 등 기술

    배치 다이어그램 (Deployment Diagram)
        : 컴포넌트 사이 종속성 표현하는 다이어그램
          결과물, 프로세스, 컴포넌트 등 물리적 요소들 위치 표현

    연관 (Association)
        : 2개 이상의 사물이 서로 관련된 상태를 표현하는 관계
          사물 사이를 실선으로 연결해 표현하며, 방향성은 화살표로 표현
          서로에게 영향 주는 양방향 관계 시 화살표 생략하고 실선으로만 연결

    컴포넌트 (Component)
        : 명백한 역할 가지고 독립적으로 존재할 수 있는 시스템 부분
          넓은 의미에서 재사용되는 모든 단위라고 볼 수 있으며, 인터페이스를 통해서만 접근 가능

    피드백 (Feedback)
        : 시스템의 상태와 사용자의 지시에 대한 효과 보여줘 사용자가 명령에 대한 진행 상황과 표시된 내용 해석할 수 있도록 도와주는 것

    모듈 (Module)
        : 독립된 하나의 소프트웨어 or 하드웨어 단위 지칭 용어

    해시 (Hash)
        : 일방향 암호 방식으로 임의 길이 정보를 입력받아, 고정된 길이 암호문 (해시값)을 출력하는 방식


#### 아키텍처 설계과정
<span style="color:blue">설계 목표 설정</span> <br>
    :설계 영향 주는 비즈니스 목표, 우선순위 등 요구사항 분석해 전체 시스템 설계 목표 설정

<span style="color:blue">시스템 타입 결정</span> <br>
    : 시스템과 서브 시스템 타입 결정하고, 설계 목표 고려해 아키텍처 패턴 선택

<span style="color:blue">스타일 적용 및 커스터마이즈</span> <br>
    : 아키텍처 패턴 참조 시스템 표준 아키텍처 설계

<span style ="color:blue">서브 시스템 기능, 인터페이스 동작 작성</span> <br>
    : 서브 시스템 기능 및 서브 시스템 간 상호작용 위한 동작과 인터페이스 정의

<span style ="color:blue">아키텍처 설계 검토</span> <br>
    : 아키텍처 설계 목표 부합 여부, 요구사항 반영 여부, 설계 기본원리 만족 여부 등 검토


#### <span style="color:blue"> 소프트웨어 개발 영역 결정 요소 </span>
    기능(Function)
    성능(Performance)
    신뢰도
    제약 조건(Constraint)
    인터페이스(Interface)
        - 소프트웨어에 의해 간접적으로 제어되는 장치와 소프트웨어 실행하는 하드웨어
        - 기존 소프트웨어와 새로운 소프트웨어 연결하는 소프트웨어
        - 순서적 연산 의해 소프트웨어 실행하는 절차


#### 기능 모델링
| 기능 모델링 순서 | 내용 |
| --- | --- |
| 입출력 자료 정의 | 외부 시스템 간 입출력 자료 정의 |
| 자료 흐름도 작성 | 입출력 자료 정의 기반 시스템 주요 기능 나타내는 자료 흐름도(Data Flow Diagram) 작성 |
| 기능 명세서 작성 | 프로세스 기능 정의를 기능 명세서로 작성 |
| 제약 조건 파악 | 시스템 동작에 영향 주는 제약 조건 파악 |


#### 프로토타입 방법
    - 최종 결과물 만들어지기 전 의뢰자가 최종 결과물 일부 or 모형 확인 가능
    - 발주자 or 개발자 모두에게 공동의 참조 모델 제공
    - 구현 단계의 구현 골격
    - 고객이 요구한 주요 기능을 프로토타입으로 구현해 고객의 피드백을 통해 개선, 보완하여 완성 소프트웨어를 만들어가는 모델


#### 소프트웨어 개발
    요구사항 분석
        - 소프트웨어가 무엇을 해야 하는가를 추적해 요구사항 명세를 작성하는 작업
        - 사용자의 요구를 추출해 목표를 정하고 어떤 방식으로 해결할 것인지 결정하는 단계
        - 소프트웨어 개발의 출발점이면서 실질적인 첫 번째 단계
    설계
    구현
    테스트
        - 소프트웨어 시스템이 사용되는 동안 발견되는 오류를 정리하는 단계
    유지보수 단계


#### 설계 방법
    상향식 설계 방법
        - 하위 기능들로부터 시작해 제일 상위에 있는 기능(Main User Function)에 접근해가는 방식
        - 최하위 수준에서 각각의 모듈들을 상세하게 설계하고 모듈이 완성되면 전체적으로 이들을 결합해 설계하는 방식
        - 인터페이스가 이미 성립되어 있어야지 기능 추가가 쉬음
    하향식 설계 방법
        - 통합 검사 시 인터페이스가 이미 정의되어 있어 통합이 간단함
        - 레벨이 낮은 데이터 구조의 세부 사항은 설계 초기 단계에서 필요


#### 자료 흐름도 (DFD)
    Process : 원
    Data Flow : 화살표
    데이터 저장소 (Data Store) : 평행선(=)
                                데이터가 저장된 장소
                                평행선 안에는 데이터 저장소 이름 넣음
    Terminator : 사각형


#### 모델 (Model)
    - 객체, 시스템, 개념에 대한 구조 or 작업을 보여주기 위한 패턴
    - 개발 대상을 추상화하고 기호 or 그림 등으로 시각적으로 표현
    - 소프트웨어에 대한 이해도 향상 가능, 이해 당사자 간 의사소통 향상됨
    - 향후 개발될 시스템에 대한 유추 가능


#### 애자일 (Agile) 기법 중 스크럼 (Scrum)
    스크럼 마스터 (Scrum Master)
        : 스크럼 프로세스 따르고, 팀이 스크럼을 효과적으로 활용할 수 있도록 보장하는 역할 등 맡음
    제품 백로그 (Product Backlog)
        : 스크럼 팀이 해결해야 하는 목록으로 소프트웨어 요구사항, 아키텍처 정의 등 포함될 수 있음
    스프린트 (Sprint)
        : 2 ~ 4주 짧은 개발 기간으로 반복적 수행으로 개발 품질 향상함
    속도 (Velocity)
        : 한 번의 스프린트에서 한 팀이 어느 정도 제품 백로그를 감당할 수 있는지에 대한 추정치로 볼 수 있음


#### 구조적 다이어그램 (Structural Diagram) / 정적 다이어그램 (Static Diagram)
***클객 컴배 복패***

    클래스
    객체
    컴포넌트
    배치
    복합체 구조
    패키지


#### Man Month 기법 프로젝트 기간 산정
    Man Month = LOC / 프로그래머의 월간 생산성
    프로젝트 기간 = Man Month / 프로젝트 인력
        (ex) 예측된 총 라인 수 36,000라인, 개발 참여할 프로그래머 6명, 프로그래머들 평균 생산성 월간 300라인
                Man Month = 36,000 / 300 = 120
                프로젝트 기간 = 120 / 6 = 20개월


#### 객체지향 설계 원칙 (SOLID)
    단일 책임 원칙
        : 하나의 클래스는 하나의 목적을 위해 생성되며, 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어 있어햐 한다는 원칙
    개방 폐쇄 원칙
        : 소프트웨어 구성요소 (컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려 있고, 변경에는 닫혀있어야 한다는 원칙
    리스코프 치환의 원칙
        : 서브 타입 (상속받은 하위 클래스)은 어디서나 자신의 기반 타입 (상위 클래스)으로 교체할 수 있어야 한다는 원칙
    인터페이스 분리의 원칙
        : 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙
    의존성 역전의 원칙 
        : 실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고받음으로 관계를 최대한 느슨하게 만드는 원칙


#### <span style="color:blue"> GoF (Gangs of Four) 생성 패턴 </span>
***생빌 프로 팩앱싱***

     생성
        빌더 (Builder)
        프로토타입
        팩토리 메서드
        앱스트랙 팩토리
        싱글톤


#### 사용자 인터페이스 설계
    - 사용성을 가장 우선적으로 고려하여 설계해야 함
    - 효율성있게 설계해야 함
    - 발생하는 오류를 쉽게 수정할 수 있어야 함
    - 사용자에게 피드백 제공할 수 있도록 설계해야 함


#### 순차 다이어그램 (= 시퀀스 다이어그램)
    동적 다이어그램
    객체 간 동적 상호작용을 시간 개념을 중심으로 모델링 하는 것
    객체 간 상호 작용을 메시지 흐름으로 표현
    객체 사이 메시지를 보내는 시간을 표현하고 일반적으로 다이어그램 수직 방향이 시간 흐름 나타냄
    구성요소에는 객체, 생명선, 실행, 메시지, 회귀 메시지 (Self-Message), 제어블록(Statement block) 등 있음


#### 메시지 지향 미들웨어 (MOM : Message-Oriented Middleware)
    메시지 기반 비동기형 메시지 전달 방식 미들웨어
        비동기적 : 요청 보내고 응답 받을 때까지 기다리지 않고, 다른 작업 수행하다 나중에 확인하는 방식
                  즉각적인 응답 원하는 경우 아닌 다소 느리고 안정적인 응답 필요로 하는 경우에 많이 사용
    독립적인 애플리케이션을 하나의 통합된 시스템으로 묶기 위한 역할
    송신 측과 수신 측 연결 시 메시지 큐 활용


#### 유스케이스 (Use Case) 구성요소 간 관계
    연관 관계 (Association)
        : 유스케이스와 액터 간 상호작용 있음 표현
          유스케이스와 액터를 실선으로 연결
    포함 관계 (Include) 
        : 하나의 유스케이스가 다른 유스케이스 실행을 전제로 할 때 형성되는 관계
          화살표를 점선으로 연결하고 <<include>>라고 표기
    확장 관계 (Extend)
        : 특정 조건에 따라 확장 기능 유스케이스 수행하는 관계
    일반화 관계 (Generalization)
        : 유사한 유스케이스 or 액터를 모아 추상화한 유스케이스 or 액터와 연결시켜 그룹을 만들어 이해도를 높이기 위한 관계


#### 익스트림 프로그래밍 (XP : eXtreme Programming)
    : 애자일 방법론
      의사소통 개선과 즉각적 피드백으로 소프트웨어 품질 높이기 위한 방법론
      기존 방법론에 비해 실용성 강조
      소규모 개발 조직이 불확실하고 변경 많은 요구 접했을 때 적절한 방법
      구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어올리는 것
      구체적인 실천 방법 정의하고 있으며, 개발 문서보다 소스 코드에 중점 둠


#### 미들웨어 (Middleware)
    서비스 이용 위해 사용자가 정보 교환 방법 등 내부 동작 확인할 필요 X
    여러 운영체제에서 응용 프로그램들 사이 위치한 소프트웨어
    소프트웨어 컴포넌트 연결하기 위한 준비된 인프라 구조 제공
    여러 컴포넌트를 1대 1, 1대 다, 다대다 등 여러 가지 형태로 연결 가능


#### <span style="color:blue"><다형성 (Polymorphism) </span>
    하나의 메시지에 각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력
    현재 코드를 변경 않고 새로운 클래스를 쉽게 추가할 수 있게 하고 상속받은 여러 개 하위 객체들이 다른 형태 특성 갖는 객체로 이용될 수 있는 성질
    여러 가지 형태를 가지고 있다는 의미로, 여러 형태 받아들일 수 있는 특징 말함
    오버로딩 (Overloading)
        : 매개변수 유형과 개수가 다르게 하여 같은 이름 메서드 여러 개 가지는 기법
    오버라이딩 (Overriding)
        : 상위 클래스에서 정의한 일반 메서드 구현을 하위 클래스에서 무시하고 재정의할 수 있는 기법


#### 객체
    상태, 동작, 고유 식별자 가진 모든 것
    필요한 자료 구조와 이에 수행되는 함수들을 가진 하나의 독립된 존재
    상태는 속성값에 의해 정의됨


#### 디자인 패턴 종류
***구 브데 퍼플 프록 컴 어***
    구조 패턴
        - 브리지 (Bridge)
        - 데코레이터 (Decorator)
        - 퍼사이드 (Facade)
        - 플라이 웨이트 (Flyweight)
        - 프록시 (Proxy)
        - 컴포지트 (Composite)
        - 어댑터 (Adapter)


#### UI 유형
    GUI (Graphical User Interface)
        : 그래픽 환경 기반으로 한 마우스 or 전자펜 이용하는 사용자 인터페이스
    OUI (Organic Interface)
        : 입력장치가 곧 출력장치 되고, 현실에 존재하는 모든 사물이 입출력 장치로 변화할 수 있는 사용자 인터페이스
    NUI (Natural User Interface)
        : 멀티 터치 (Multi-touch), 동작 인식 (Gesture Recognition) 등 사용자 자연스러운 움직임 인식 서로 주고받는 정보 제공 사용자 인터페이스
    CLI (Command Line Interface)
        : 명령어를 텍스트로 입력해 조작하는 사용자 인터페이스


#### 모델링
    개발될 시스템에 대해 여러 분야 엔지니어들이 공통된 개념 공유하는데 도움 줌
    개발될 소프트웨어에 대한 이해도 및 이해 당사자 간 의사소통 향상에 도움 됨
    개발팀이 응용문제 이해하는 데 도움 줄 수 있음
    모델링 작업 결과물은 다른 모델링 작업에 영향 줄 수 있음
    절차적인 프로그램 위한 자료 흐름도는 프로세스 위주 모델링 방법
    구조적 방법론에서 DFD (Data Flow Diagram), DD (Data Dictionary) 등 사용해 요구사항 결과 표현
    객체지향 방법론에서는 UML 표기법 사용


#### 유스케이스 다이어그램 (Use Case Diagram)
    사용자 관점에서 시스템의 활동을 표현하는 동적 다이어그램
    액터는 구현 대상이 아닌 시스템 외부에서 시스템과 상호작용하는 존재로 사람뿐만 아니라 외부 시스템도 액터로 표현될 수 있음
    사용자 측면에서의 요구사항으로, 사용자가 원하는 목표 달성 위해 수행할 내용 기술
    시스템 액터 : 다른 프로그램에서 이미 개발되어 사용되고 있으며, 본 시스템과 데이터 주고받는 등 서로 연동되는 시스템
    액터가 인식할 수 없는 시스템 내부 기능을 하나의 유스케이스로 파악해서는 안됨


#### MVC (Model-View-Controller)
    사용자 인터페이스를 담당하는 계층 응집도를 높일 수 있고, 여러 개의 다른 UI를 만들어 그 사이 결합도를 낮출 수 있음
    제어 (Controller)는 뷰 (View)와 모델 (Model) 사이에서 전달자 역할 수행
    뷰마다 컨트롤러 서브 시스템이 각각 하나씩 연결
    뷰 (View)는 모델 (Model)에 있는 데이터를 사용자 인터페이스에 보이는 역할 담당
    제어 (Controller)는 모델 (Model)에 명령 보냄으로 모델의 상태 변경 가능

















