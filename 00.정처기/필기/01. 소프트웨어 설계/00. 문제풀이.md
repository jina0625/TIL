#### 용어 정리
<span style="color:blue">FEP (Front-End Processor) </span> <br>
        : 입력되는 데이터를 컴퓨터 프로세서가 처리하기 전 미리 처리해 프로세서가 처리하는 시간 줄여주는 프로그램 or 하드웨어

<span style="color:blue">EAI (Enterprise Application Integration) </span> <br>
        : 비즈니스 프로세스 중심으로 어댑터 이용해 기업 내 각종 플랫폼 및 애플리케이션 간 상호 연동 가능하도록 통합하는 솔루션

<span style="color:blue">GPL (General Public License) </span> <br>
        : 자유 소프트웨어 재단에서 만든 오픈 소스 소프트웨어 라이선스
          GPL 파생 저작물 조항에 의한 소스 코드 배포 의무 O

    DuPlexing
        : 단일 매체, 장치, 포트에서 '동시 양방향 통신' 가능하게 하는 전송방식

    위험 모니터링
        : 위험 요소 징후들에 대해 계속적으로 인지하는 것

    SRS (Software REquest Specification)
        : 시스템에서 구현되어야 할 것에 대한 공식적인 문장으로 사용자, 시스템을 명세화한 산출물

    Tailoring
        : 프로젝트 특성과 필요 따라 소프트웨어 개발 프로세스를 적합한 규모로 가공하는 과정 및 방법론
    
    CMMi
        : 기존 CMM 모델 통합하고 ISO15504 준수하는 소프트웨어 개발 능력 / 성숙도 평가 및 프로세스 개선 활동의 지속적인 품질 개선 모델
    
    SPICE
        : 소프트웨어 프로세스 평가하고 개선함으로 품질 및 생산성 높이고자 하는 국제표준 (ISO15504)

<span style="color:blue"> 캡슐화 (Encapsulation) </span> <br>
        : 서로 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만 밖으로 드러내는 기법 <br>
          객체의 속성과 기능을 하나로 묶어서 외부로부터 은닉하는 것

    UML
        : 객체지향 시스템 개발 시 산출물을 명세화, 시각화, 문서화하는 데 사용됨
          개발하는 시스템을 이해하기 쉬운 형태로 표현해 분석가, 의뢰인, 설계자가 효율적인 의사소통 할 수 있게 해줌
          개발 방법론 or 개발 프로세스가 아닌 표준화된 모델링 언어

    목업 (Mockup)
        : 디자인, 사용방법설명, 평가 등 위해 실제 화면과 유사하게 만든 정적 형태 모형
          시각적으로만 구성요소 배치하는 것으로 일반적으로 실제로 구현되지 X

    스토리보드 (Storyboard)
        : 정책, 프로세스, 콘텐츠 구성, 와이어프레임 (UI, UX), 기능 정의, 데이터베이스 연동 등 서비스 구축을 위한 모든 정보 담긴 설계 산출물

    프로토타입 (Prototype)
        : 정적 화면으로 설계된 와이어프레임 or 스토리보드에 동적 효과를 적용함으로써 실제 구현된 것처럼 시뮬레이션할 수 있는 모형

    디자인 패턴
        : 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법 정리한 패턴
          디자인 패턴 참고해 개발 시 개발 효율성, 유지 보수성, 운용성 등 품질 높아지며 프로그램 최적화에 도움됨

<span style="color:blue"> 클래스 (Class) </span> <br>
        : 객체 지향 개념 중 하나 이상의 유사한 객체들을 묶어 공통된 특성 표현한 데이터 추상화를 의미하는 것 <br>
          공통의 속성 공유하는 객체들 집합

    메서드 (Method)
        : 클래스로부터 생성된 객체 사용하는 방법

    필드 (Field)
        : 클래스에 포함된 변수 (Variable)

    메시지 (Message)
        : 객체 간 상호작용 하기 위한 수단
          객체에게 어떤 행위 하도록 지시하는 방법

    비기능적 요구사항 
        : 시스템 특성, 품질, 제약사항, 성능, 가용성, 사용 용이성, 유지보수 용이성, 안전성, 보안성 관련 사항
          (ex) 차량 대여 시스템이 제공하는 모든 화면이 3초 내 사용자에게 보여야 한다 -> 성능과 관계된 비기능적 요구사항

    ERD (Entity-Relationship Diagram)
        : 정보공학 방법론에서 데이터베이스 설계 표현으로 사용하는 모델링 언어

    패키지 다이어그램 (Package Diagram)
        : 유스케이스 or 클래스 등 모델 요소들을 그룹화한 패키지들의 관계 표현하는 다이어그램

    상태 전이 다이어그램 (State Transition Diagram)
        : 하나의 객체가 자신이 속한 클래스의 상태 변화 or 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현하는 다이어그램
          모든 가능한 상태와 전이 표현
          진입 조건, 탈출 조건, 상태 전이 등 기술

    배치 다이어그램 (Deployment Diagram)
        : 컴포넌트 사이 종속성 표현하는 다이어그램
          결과물, 프로세스, 컴포넌트 등 물리적 요소들 위치 표현

    연관 (Association)
        : 2개 이상의 사물이 서로 관련된 상태를 표현하는 관계
          사물 사이를 실선으로 연결해 표현하며, 방향성은 화살표로 표현
          서로에게 영향 주는 양방향 관계 시 화살표 생략하고 실선으로만 연결

    컴포넌트 (Component)
        : 명백한 역할 가지고 독립적으로 존재할 수 있는 시스템 부분
          넓은 의미에서 재사용되는 모든 단위라고 볼 수 있으며, 인터페이스를 통해서만 접근 가능

    피드백 (Feedback)
        : 시스템의 상태와 사용자의 지시에 대한 효과 보여줘 사용자가 명령에 대한 진행 상황과 표시된 내용 해석할 수 있도록 도와주는 것

    모듈 (Module)
        : 독립된 하나의 소프트웨어 or 하드웨어 단위 지칭 용어

    해시 (Hash)
        : 일방향 암호 방식으로 임의 길이 정보를 입력받아, 고정된 길이 암호문 (해시값)을 출력하는 방식

    Dependency
        : 한 사물의 명세가 바뀌면 다른 사물에 영향 주는 관계
        일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개변수로 사용하는 경우 나타나는 관계

    Association
        : 두 사물 간 연관 관계 나타내는 관게

    Realization
        : 한 사물이 다른 사물의 기능을 구현하는 관계

    Generalization
        : 한 사물이 다른 사물의 일반화된 형태를 나태는 관계

    AVL Diagram 
        : 자료구조 표현하는 다이어그램
          균형 트리 표현하는 다이어그램
                균형 트리
                    : 이진 트리 일종
                      각 노드의 왼쪽 서브트리와 오른쪽 서브트리 높이 차이가 1 넘지 않도록 유지되는 트리 

    Operation
        : 클래스 동작 의미
          클래스에 속하는 객체에 대해 적요오딜 메서드 정의한 것
          UML에서는 동작에 대한 인터페이스를 지칭한다고 볼수 있음

    사용자 인터페이스 (User Interface)
        : 사용자와 시스템이 정보를 주고받는 상호작용이 잘 이뤄지도록 하는 장치 or 소프트웨어

    정적 모델링
        : 시스템의 구조 파악하고 표현하는 모델링
          패키지 다이어그램, 구성 다이어그램 등 사용


#### 아키텍처 설계과정
<span style="color:blue">설계 목표 설정</span> <br>
    :설계 영향 주는 비즈니스 목표, 우선순위 등 요구사항 분석해 전체 시스템 설계 목표 설정

<span style="color:blue">시스템 타입 결정</span> <br>
    : 시스템과 서브 시스템 타입 결정하고, 설계 목표 고려해 아키텍처 패턴 선택

<span style="color:blue">스타일 적용 및 커스터마이즈</span> <br>
    : 아키텍처 패턴 참조 시스템 표준 아키텍처 설계

<span style ="color:blue">서브 시스템 기능, 인터페이스 동작 작성</span> <br>
    : 서브 시스템 기능 및 서브 시스템 간 상호작용 위한 동작과 인터페이스 정의

<span style ="color:blue">아키텍처 설계 검토</span> <br>
    : 아키텍처 설계 목표 부합 여부, 요구사항 반영 여부, 설계 기본원리 만족 여부 등 검토


#### <span style="color:blue"> 소프트웨어 개발 영역 결정 요소 </span>
    기능(Function)
    성능(Performance)
    신뢰도
    제약 조건(Constraint)
    인터페이스(Interface)
        - 소프트웨어에 의해 간접적으로 제어되는 장치와 소프트웨어 실행하는 하드웨어
        - 기존 소프트웨어와 새로운 소프트웨어 연결하는 소프트웨어
        - 순서적 연산 의해 소프트웨어 실행하는 절차


#### 기능 모델링
| 기능 모델링 순서 | 내용 |
| --- | --- |
| 입출력 자료 정의 | 외부 시스템 간 입출력 자료 정의 |
| 자료 흐름도 작성 | 입출력 자료 정의 기반 시스템 주요 기능 나타내는 자료 흐름도(Data Flow Diagram) 작성 |
| 기능 명세서 작성 | 프로세스 기능 정의를 기능 명세서로 작성 |
| 제약 조건 파악 | 시스템 동작에 영향 주는 제약 조건 파악 |


#### 프로토타입 방법
    - 최종 결과물 만들어지기 전 의뢰자가 최종 결과물 일부 or 모형 확인 가능
    - 발주자 or 개발자 모두에게 공동의 참조 모델 제공
    - 구현 단계의 구현 골격
    - 고객이 요구한 주요 기능을 프로토타입으로 구현해 고객의 피드백을 통해 개선, 보완하여 완성 소프트웨어를 만들어가는 모델


#### 소프트웨어 개발
    요구사항 분석
        - 소프트웨어가 무엇을 해야 하는가를 추적해 요구사항 명세를 작성하는 작업
        - 사용자의 요구를 추출해 목표를 정하고 어떤 방식으로 해결할 것인지 결정하는 단계
        - 소프트웨어 개발의 출발점이면서 실질적인 첫 번째 단계
    설계
    구현
    테스트
        - 소프트웨어 시스템이 사용되는 동안 발견되는 오류를 정리하는 단계
    유지보수 단계


#### 설계 방법
    상향식 설계 방법
        - 하위 기능들로부터 시작해 제일 상위에 있는 기능(Main User Function)에 접근해가는 방식
        - 최하위 수준에서 각각의 모듈들을 상세하게 설계하고 모듈이 완성되면 전체적으로 이들을 결합해 설계하는 방식
        - 인터페이스가 이미 성립되어 있어야지 기능 추가가 쉬음
    하향식 설계 방법
        - 통합 검사 시 인터페이스가 이미 정의되어 있어 통합이 간단함
        - 레벨이 낮은 데이터 구조의 세부 사항은 설계 초기 단계에서 필요


#### 자료 흐름도 (DFD)
    Process : 원
    Data Flow : 화살표
    데이터 저장소 (Data Store) : 평행선(=)
                                데이터가 저장된 장소
                                평행선 안에는 데이터 저장소 이름 넣음
    Terminator : 사각형


#### 모델 (Model)
    - 객체, 시스템, 개념에 대한 구조 or 작업을 보여주기 위한 패턴
    - 개발 대상을 추상화하고 기호 or 그림 등으로 시각적으로 표현
    - 소프트웨어에 대한 이해도 향상 가능, 이해 당사자 간 의사소통 향상됨
    - 향후 개발될 시스템에 대한 유추 가능


#### 애자일 (Agile) 기법 중 스크럼 (Scrum)
    스크럼 마스터 (Scrum Master)
        : 스크럼 프로세스 따르고, 팀이 스크럼을 효과적으로 활용할 수 있도록 보장하는 역할 등 맡음
    제품 백로그 (Product Backlog)
        : 스크럼 팀이 해결해야 하는 목록으로 소프트웨어 요구사항, 아키텍처 정의 등 포함될 수 있음
    스프린트 (Sprint)
        : 2 ~ 4주 짧은 개발 기간으로 반복적 수행으로 개발 품질 향상함
    속도 (Velocity)
        : 한 번의 스프린트에서 한 팀이 어느 정도 제품 백로그를 감당할 수 있는지에 대한 추정치로 볼 수 있음


#### 구조적 다이어그램 (Structural Diagram) / 정적 다이어그램 (Static Diagram)
***클객 컴배 복패***

    클래스
    객체
    컴포넌트
    배치
    복합체 구조
    패키지


#### Man Month 기법 프로젝트 기간 산정
    Man Month = LOC / 프로그래머의 월간 생산성
    프로젝트 기간 = Man Month / 프로젝트 인력
        (ex) 예측된 총 라인 수 36,000라인, 개발 참여할 프로그래머 6명, 프로그래머들 평균 생산성 월간 300라인
                Man Month = 36,000 / 300 = 120
                프로젝트 기간 = 120 / 6 = 20개월


#### 객체지향 설계 원칙 (SOLID)
    단일 책임 원칙
        : 하나의 클래스는 하나의 목적을 위해 생성되며, 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어 있어햐 한다는 원칙
    개방 폐쇄 원칙
        : 소프트웨어 구성요소 (컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려 있고, 변경에는 닫혀있어야 한다는 원칙
    리스코프 치환의 원칙
        : 서브 타입 (상속받은 하위 클래스)은 어디서나 자신의 기반 타입 (상위 클래스)으로 교체할 수 있어야 한다는 원칙
    인터페이스 분리의 원칙
        : 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙
    의존성 역전의 원칙 
        : 실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고받음으로 관계를 최대한 느슨하게 만드는 원칙


#### GoF (Gang of Four) 디자인 패턴
    디자인 패턴을 목적 (Purpose)으로 분류 시 생성, 구조, 행위로 분류 할 수 있음
    Strategy 패턴
        : 행위 패턴
          알고리즘을 클래스로 캡슐화해 다양한 알고리즘 사용할 수 있는 유연성 제공
    행위 패턴
        : 클래스 or 객체들이 상호작용하는 방법과 책임을 분산하는 방법 정의
    

#### <span style="color:blue"> GoF (Gangs of Four) 생성 패턴 </span>
***생빌 프로 팩앱싱***

     생성
        빌더 (Builder)
        프로토타입
        팩토리 메서드
        앱스트랙 팩토리
        싱글톤 (Singleton)
            : 특정 클래스 인스턴스가 오직 하나임을 보장하고, 이 인스턴스에 대한 접근 방법 제공


#### 사용자 인터페이스 설계
    사용성을 가장 우선적으로 고려하여 설계해야 함
    효율성있게 설계해야 함
    발생하는 오류를 쉽게 수정할 수 있어야 함
    사용자에게 피드백 제공할 수 있도록 설계해야 함
    배우기 용이하고 쉽게 사용할 수 있도록 만들어져야 함
    사용자 요구사항이 UI에 반영될 수 있도록 구성해야 함


#### <span style="color:blue"> 순차 다이어그램 (= 시퀀스 다이어그램) </span> <br>
    동적 다이어그램
    객체들 상호 작용 나타내기 위해 사용
    교류 다이어그램 (Interaction Diagram) 한 종류로 볼 수 있음
    객체 간 동적 상호작용을 시간 개념을 중심으로 모델링 하는 것
    객체 간 상호 작용을 메시지 흐름으로 표현
    객체 사이 메시지를 보내는 시간을 표현하고 일반적으로 다이어그램 수직 방향이 시간 흐름 나타냄
    구성요소에는 객체, 생명선, 실행, 메시지, 회귀 메시지 (Self-Message), 제어블록(Statement block) 등 있음


#### 메시지 지향 미들웨어 (MOM : Message-Oriented Middleware)
    메시지 기반 비동기형 메시지 전달 방식 미들웨어
        비동기적 : 요청 보내고 응답 받을 때까지 기다리지 않고, 다른 작업 수행하다 나중에 확인하는 방식
                  즉각적인 응답 원하는 경우 아닌 다소 느리고 안정적인 응답 필요로 하는 경우에 많이 사용
    독립적인 애플리케이션을 하나의 통합된 시스템으로 묶기 위한 역할
    송신 측과 수신 측 연결 시 메시지 큐 활용


#### 유스케이스 (Use Case) 구성요소 간 관계
    연관 관계 (Association)
        : 유스케이스와 액터 간 상호작용 있음 표현
          유스케이스와 액터를 실선으로 연결
    포함 관계 (Include) 
        : 하나의 유스케이스가 다른 유스케이스 실행을 전제로 할 때 형성되는 관계
          화살표를 점선으로 연결하고 <<include>>라고 표기
    확장 관계 (Extend)
        : 특정 조건에 따라 확장 기능 유스케이스 수행하는 관계
    일반화 관계 (Generalization)
        : 유사한 유스케이스 or 액터를 모아 추상화한 유스케이스 or 액터와 연결시켜 그룹을 만들어 이해도를 높이기 위한 관계


#### <span style="color:blue"> 익스트림 프로그래밍 (XP : eXtreme Programming) </span> <br>
    : 애자일 방법론
      의사소통 개선과 즉각적 피드백으로 소프트웨어 품질 높이기 위한 방법론
      기존 방법론에 비해 실용성(Pragmatism) 강조
      소규모 개발 조직이 불확실하고 변경 많은 요구 접했을 때 적절한 방법
      구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어올리는 것
      구체적인 실천 방법 정의하고 있으며, 개발 문서보다 소스 코드에 중점 둠
      빠른 개발과 품질을 동시에 달성하기 위해 테스트 중요하게 생각
        테스트 주도 개발(TDD) : 테스트 코드 먼저 작성 후, 테스트 코드를 통과하는 코드 작성하는 방식으로 개발 진행
      사용자 요구사항은 언제든지 변할 수 있음
      고객과 직접 대면하며 요구사항을 이야기하기 위해 사용자 스토리(User Story) 활용 가능
      

#### <span style="color:blue"> 미들웨어 (Middleware) </span>
    서비스 이용 위해 사용자가 정보 교환 방법 등 내부 동작 확인할 필요 X
    여러 운영체제에서 응용 프로그램들 사이 위치한 소프트웨어
    소프트웨어 컴포넌트 연결하기 위한 준비된 인프라 구조 제공
    여러 컴포넌트를 1대 1, 1대 다, 다대다 등 여러 가지 형태로 연결 가능
    분산 시스템에서 다양한 부분 관리하고 통신하며 데이터 교환하게 해주는 소프트웨어
    위치 투명성 (Location Transparency) 제공하여 애플리케이션이 컴퓨터의 위치에 관계없이 다른 컴퓨터에 있는 컴포넌트와 통신할 수 있도록 함
    분산 시스템의 여러 컴포넌트가 요구하는 재사용 가능한 서비스 구현 제공
    애플리케이션과 운영체제, 하드웨어 사이 분산 시스템의 다양한 부분 관리하고 통신하며 데이터 교환하게 해주는 소프트웨어


#### <span style="color:blue"><다형성 (Polymorphism) </span>
    하나의 메시지에 각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력
    현재 코드를 변경 않고 새로운 클래스를 쉽게 추가할 수 있게 하고 상속받은 여러 개 하위 객체들이 다른 형태 특성 갖는 객체로 이용될 수 있는 성질
    여러 가지 형태를 가지고 있다는 의미로, 여러 형태 받아들일 수 있는 특징 말함
    오버로딩 (Overloading)
        : 매개변수 유형과 개수가 다르게 하여 같은 이름 메서드 여러 개 가지는 기법
    오버라이딩 (Overriding)
        : 상위 클래스에서 정의한 일반 메서드 구현을 하위 클래스에서 무시하고 재정의할 수 있는 기법


#### <span style="color:blue"> 객체 </span>
    상태, 동작, 고유 식별자 가진 모든 것
    필요한 자료 구조와 이에 수행되는 함수들을 가진 하나의 독립된 존재
    상태는 속성값에 의해 정의됨
    실세계에 존재 or 생각할 수 있는 것


#### 디자인 패턴 종류
***구 브데 퍼플 프록 컴 어***
    구조 패턴
        - 브리지 (Bridge)
        - 데코레이터 (Decorator)
        - 퍼사이드 (Facade)
        - 플라이 웨이트 (Flyweight)
        - 프록시 (Proxy)
        - 컴포지트 (Composite)
        - 어댑터 (Adapter)


#### <span style="color:blue"> UI 유형 </span>
    GUI (Graphical User Interface)
        : 그래픽 환경 기반으로 한 마우스 or 전자펜 이용하는 사용자 인터페이스
    OUI (Organic Interface)
        : 입력장치가 곧 출력장치 되고, 현실에 존재하는 모든 사물이 입출력 장치로 변화할 수 있는 사용자 인터페이스
    NUI (Natural User Interface)
        : 멀티 터치 (Multi-touch), 동작 인식 (Gesture Recognition) 등 사용자 자연스러운 움직임 인식 서로 주고받는 정보 제공 사용자 인터페이스
    CLI (Command Line Interface)
        : 명령어를 텍스트로 입력해 조작하는 사용자 인터페이스
          DOs 및 Unix 등 운영체제에서 조작위해 사용
    CUI (Cell User Interface)
        : 셀 기반 사용자 인터페이스
          엑셀 or 워드프로세서 등 프로그램에서 사용되는 인터페이스
    MUI (Mobile User Interface)
        : 모바일 기기에서 사용하는 사용자 인터페이스
          터치스크린 사용해 아이콘 or 메뉴 선택하여 시스템 조작


#### <span style="color:blue"> 모델링 </span> 
    개발될 시스템에 대해 여러 분야 엔지니어들이 공통된 개념 공유하는데 도움 줌
    개발될 소프트웨어에 대한 이해도 및 이해 당사자 간 의사소통 향상에 도움 됨
    개발팀이 응용문제 이해하는 데 도움 줄 수 있음
    모델링 작업 결과물은 다른 모델링 작업에 영향 줄 수 있음
    절차적인 프로그램 위한 자료 흐름도는 프로세스 위주 모델링 방법
    구조적 방법론에서 DFD (Data Flow Diagram), DD (Data Dictionary) 등 사용해 요구사항 결과 표현
    객체지향 방법론에서는 UML 표기법 사용
    소프트웨어 개발의 모든 단계에서 활용
        (개발팀이 응용문제 이해하고, 개발될 시스템 요구사항 명확히 하며, 시스템 구조와 동작 설계, 시스템 구현, 시스템 품질 보증 시 활용)


#### 유스케이스 다이어그램 (Use Case Diagram)
    사용자 관점에서 시스템의 활동을 표현하는 동적 다이어그램
    액터는 구현 대상이 아닌 시스템 외부에서 시스템과 상호작용하는 존재로 사람뿐만 아니라 외부 시스템도 액터로 표현될 수 있음
    사용자 측면에서의 요구사항으로, 사용자가 원하는 목표 달성 위해 수행할 내용 기술
    시스템 액터 : 다른 프로그램에서 이미 개발되어 사용되고 있으며, 본 시스템과 데이터 주고받는 등 서로 연동되는 시스템
    액터가 인식할 수 없는 시스템 내부 기능을 하나의 유스케이스로 파악해서는 안됨


#### MVC (Model-View-Controller)
    사용자 인터페이스를 담당하는 계층 응집도를 높일 수 있고, 여러 개의 다른 UI를 만들어 그 사이 결합도를 낮출 수 있음
    제어 (Controller)는 뷰 (View)와 모델 (Model) 사이에서 전달자 역할 수행
    뷰마다 컨트롤러 서브 시스템이 각각 하나씩 연결
    뷰 (View)는 모델 (Model)에 있는 데이터를 사용자 인터페이스에 보이는 역할 담당
    제어 (Controller)는 모델 (Model)에 명령 보냄으로 모델의 상태 변경 가능


#### 요구사항 검증
    요구사항이 고객이 정말 원하는 시스템을 제대로 정의하고 있는지 검증하는 과정
    개발완료 이후 문제점 발견 시 막대한 재작업 비용 들 수 있기 때문에 요구사항 검증은 매우 중요
    요구사항이 실제 요구 반영하는지, 문서상의 요구사항은 서로 상충되지 않는지 등 점검
    모든 요구사항 문제 발견할 수 있는 것 X

#### <span style="color:blue"> 추상화 (Abstraction) </span>
        공통 성질을 추출해 추상 클래스를 설정하는 기법
        대표적 추상화 기법
            - 자료 추상화
                 : 데이터의 특징 or 구조를 강조해 데이터의 세부적인 구현 숨기는 기법
            - 제어 추상화
                : 프로그램의 제어 흐름 강조해 프로그램 세부적인 구현 숨기는 기법
            - 과정 추상화
                : 프로그램 기능 강조해 프로그램의 세부적인 구현 숨기는 기법


#### 정보 은닉 (Information Hiding)
    객체지향 설계 기본 원리 중 하나
    모듈의 내부 구현을 외부로부터 숨기는 것
    필요하지 않은 정보는 접근할수 없도록 해 한 모듈 or 하부시스템이 다른 모듈의 구현에 영향 받지 않게 설계되는 것
    모듈들 사이 독립성 유지시키는 데 도움 됨
    설계에서 은닉되어야 할 기본 정보로는 IP주소와 같은 물리적 코드, 상세 데이터 구조 등 있음
    요구사항 변화에 보다 유연하게 대응할 수 있도록 도와줌
    숨겨진 모듈 내부의 자료 구조와 접근 동작들은 필요에 따라 수정 가능
    정보 은닉 장점
        모듈들 사이 결합도 낮춰 모듈 재사용성 높일 수 있음
        모듈 내부 구현 숨겨 모듈 재설계 or 재구현 용이
        모듈 내부 구현 변경되어도 모듈 외부 인터페이스를 변경하지 않아도 되므로 유지보수성 향상


#### 요구 분석 (Requirement Analysis)
    소프트웨어 개발의 실제적인 첫 단계
    사용자 요구에 대해 이해하는 단계
    사용자의 요구를 명확히 이해하고, 소프트웨어 기능과 성능, 품질, 범위 등 정의하는 것
    요구 분석 단계
        - 요구 추출 (Requirement Elicitation)
            : 프로젝트 계획 단계에서 정의한 문제의 범위 안에 있는 사용자의 요구를 찾는 단계
        - 요구 분석 (Requirement Analysis)
            : 요구 추출 단계에서 도출된 요구를 분석하여 명확하고 구체화하는 단계
        - 요구 명세서 작성 (Requirement Specification)
            : 요구 분석 단계에서 분석된 요구를 문서화하는 단계
    도메인 분석 (Domain Analysis)
        : 요구에 대한 정보 수집하고 배경 분석해 이르 토대로 모델링 하게 됨
    기능적 (Functional) 요구
        : 시스템이 제공해야 하는 기능에 대한 요구사항 도출하는 것
          회원가입 기능, 로그인 기능, 게시글 작성 기능 등


#### 마스터-슬레이브 (Master-Slave) 아키텍처
    분산 시스템에서 흔히 사용되는 아키텍처 중 하나
    일반적으로 실시간 시스템에서 사용됨
    마스터 프로세스
        : 전체 시스템 제어 담당
          일반적으로 연산, 통신, 조정 책임짐
    슬레이브 프로세스
        : 마스터 프로세스의 지시에 따라 작업 수행
          데이터 수집 기능 수행
          데이터 수집해 마스터 프로세스에 전송 가능


#### 요구 사항 정의 및 분석, 설계 결과물 표현하기 위한 다이어그램
    데이터 흐름 다이어그램 (Data Flow Diagram)
        : 시스템의 데이터 흐름 표현하는 다이어그램
    유즈케이스 다이어그램 (Use Case Diagram)
        : 시스템의 사용자와 시스템의 상호작용 표현하는 다이어그램
    클래스 다이어그램 (Class Diagram)
        : 시스템의 클래스와 클래스 간 관계 표현하는 다이어그램
    객체 다이어그램 (Object Diagram)
        : 특정 시점에서 시스템의 객체와 객체 간 관계 표현하는 다이어그램


#### <span style="color:blue"> 럼바우 (Rumbaugh Method) </span> <br>
    객체지향 분석 기법 중 하나
    그래픽 표기법 이용해 소프트웨어 구성요소를 모델링하는 기법
    객체 모형, 동적 모형, 기능 모형의 3개 모형 생성
        - 객체 모델링
            : 시스템의 객체를 파악하고 표현하는 모델링
              클래스 다이어그램, 인터페이스 다이어그램 등 사용
        - 동적 모델링
            : 시스템 동작 파악하고 표현하는 모델링
              상태 다이어그램, 활동 다이어그램 등 사용
        - 기능 모델링
            : 시스템의 기능을 파악하고 표현하는 모델링
              자료 흐름도 (DFD), 유스케이스 다이어그램, 프로세스 다이어그램 등 사용


#### 객체지향 분석 기법
    동적 모델링 기법이 사용될 수 있음
    객체와 관계를 중심으로 시스템 파악하는 기법
    데이터와 행위를 하나로 묶어 객체를 정의내리고 추상화시키는 작업
    코드 재사용에 의한 프로그램 생산성 향상 및 요구에 따른 시스템의 쉬운 변경 가능


#### 소프트웨어 아키텍처
    외부에서 인식할 수 있는 특성 담긴 소프트웨어 골격 되는 기본 구조
    이해 관계자들의 품질 요구사항 반영해 품질 속성 결정
    파이프 필터 아키텍처
        : 데이터는 파이프를 통해 양방향으로 흐르지만, 필터 이동 시 오버헤드 발생
                필터 : 데이터 처리하는 소프트웨어 모듈
                      데이터 처리 과정에서 필터 이동해야 하는 경우, 필터 전후 처리 위한 오버헤드 발생
    데이터 중심 아키텍처
        : 공유 데이터저장소 통해 접근자 간 통신 이뤄지므로 각 접근자 수정과 확장 용이

   




















